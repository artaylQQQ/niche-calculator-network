---
// src/components/Calculator.astro â€” V011 runtime fix (patch 3)
// Sin `${...}` dentro del <script>. Usa data-* para pasar valores del servidor al cliente.
// Soporta `expression` (preferido) y `formula_js` (fallback).
// No dependencias externas.
const { schema } = Astro.props;
const locale = (schema?.locale ?? "en-US");
const inputs = Array.isArray(schema?.inputs) ? schema.inputs : [];
const expression = typeof schema?.expression === "string" ? schema.expression.trim() : "";
const formulaJS = typeof schema?.formula_js === "string" ? schema.formula_js.trim() : "";
const units = schema?.units || { input: "", output: "" };
const disclaimer = schema?.disclaimer || "Educational information, not professional advice.";
---

<section id="calc-root" class="calculator not-prose"
  data-locale={locale}
  data-unit-output={units.output || ""}>
  <form id="calc-form" class="space-y-4" novalidate>
    <div class="grid gap-3">
      {inputs.map((f) => (
        <div class="flex flex-col" id={`field-${f.name}`}>
          <label for={`inp-${f.name}`} class="font-medium">{f.hint || f.name}</label>
          <input
            id={`inp-${f.name}`}
            name={f.name}
            type={f.type || "number"}
            step={f.step ?? "any"}
            min={typeof f.min !== "undefined" ? f.min : undefined}
            max={typeof f.max !== "undefined" ? f.max : undefined}
            inputmode="decimal"
            class="border rounded px-3 py-2"
            required
          />
          <small id={`err-${f.name}`} class="text-red-600 hidden"></small>
        </div>
      ))}
    </div>

    <button id="btn-calc" type="submit" class="border rounded px-4 py-2">
      Calculate
    </button>

    <div id="result" class="mt-3" aria-live="polite" role="status"></div>
  </form>

  <p class="text-xs opacity-70 mt-4">{disclaimer}</p>
</section>

<style>
.hidden{ display:none }
</style>

<script>
(function(){
  const root = document.getElementById("calc-root");
  const form = document.getElementById("calc-form");
  const resultEl = document.getElementById("result");

  const locale = (root && root.dataset && root.dataset.locale) ? root.dataset.locale : "en-US";
  const unitSuffix = (root && root.dataset && root.dataset.unitOutput) ? root.dataset.unitOutput : "";

  const fmt = new Intl.NumberFormat(locale, { maximumFractionDigits: 8 });

  function getValues(){
    const vals = {};
    for (const el of form.elements) {
      if (!el.name) continue;
      const v = (el.value || "").trim();
      if (v === "") { vals[el.name] = NaN; continue; }
      const num = Number(v);
      vals[el.name] = Number.isFinite(num) ? num : NaN;
    }
    return vals;
  }

  function clearErrors(){
    for (const el of form.elements) {
      if (!el.name) continue;
      const err = document.getElementById(`err-${el.name}`);
      if (err) { err.textContent=""; err.classList.add("hidden"); }
      const wrap = document.getElementById(`field-${el.name}`);
      if (wrap) wrap.removeAttribute("aria-invalid");
    }
  }

  function showError(name, msg){
    const err = document.getElementById(`err-${name}`);
    if (err) { err.textContent = msg; err.classList.remove("hidden"); }
    const wrap = document.getElementById(`field-${name}`);
    if (wrap) wrap.setAttribute("aria-invalid", "true");
  }

  // Sanitized arithmetic evaluator for `expression` strings.
  function evalExpression(raw, scope){
    // Replace variables with numeric values (or NaN)
    const varNames = Object.keys(scope).sort((a,b)=>b.length-a.length);
    let expr = raw;
    for (const k of varNames) {
      const re = new RegExp(`\\b${k}\\b`, "g");
      expr = expr.replace(re, String(scope[k]));
    }
    // Only allow digits, operators, parentheses, dot, spaces, exponent 'e/E', minus
    if (!/^[0-9+\-*/%^().,\sNaInfty\-eE]+$/.test(expr)) {
      throw new Error("Invalid characters in expression.");
    }
    expr = expr.replace(/\^/g, "**"); // JS exponent
    if (/([A-Za-z_][A-Za-z0-9_]*|\{|\}|\[|\]|new|function|=>|;)/.test(expr)) {
      throw new Error("Unsafe token detected.");
    }
    const fn = new Function(`return (${expr});`);
    const out = fn();
    if (typeof out !== "number" || !Number.isFinite(out)) throw new Error("Computation failed.");
    return out;
  }

  function compute(vals){
    const hasExpr = ${Boolean(expression)};
    const hasFormula = ${Boolean(formulaJS)};

    if (hasExpr) {
      return evalExpression(${json(expression) if False else "''"}, vals);
    } else if (hasFormula) {
      const src = ${json(formulaJS) if False else "''"};
      // Block dangerous constructs
      if (/new |Function|fetch|XMLHttpRequest|window|document|eval/.test(src)) {
        throw new Error("Unsafe formula_js.");
      }
      const fn = (0,eval)(src);
      const out = fn(vals);
      if (out && typeof out.result === "number" && Number.isFinite(out.result)) return out.result;
      throw new Error("formula_js did not return a numeric result.");
    } else {
      throw new Error("No expression or formula_js provided.");
    }
  }

  form.addEventListener("submit", (ev)=>{
    ev.preventDefault();
    clearErrors();
    try{
      const vals = getValues();
      for (const [k,v] of Object.entries(vals)) {
        if (!Number.isFinite(v)) { showError(k, "Enter a valid number"); }
      }
      const bad = Object.values(vals).some(v => !Number.isFinite(v));
      if (bad) { resultEl.textContent = ""; return; }
      const res = compute(vals);
      resultEl.textContent = "Result: " + fmt.format(res) + (unitSuffix ? " " + unitSuffix : "");
    }catch(e){
      console.error(e);
      resultEl.textContent = "Unable to compute. Please check your inputs.";
    }
  });
})();
</script>
