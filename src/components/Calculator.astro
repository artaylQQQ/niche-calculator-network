---
// src/components/Calculator.astro â€” V011 runtime fix
// Supports `expression` (preferred) or `formula_js` (legacy fallback).
// Pure client-side, no dependencies.
const { schema } = Astro.props;
const locale = schema?.locale || "en-US";
const title = schema?.title || "Calculator";
const inputs = Array.isArray(schema?.inputs) ? schema.inputs : [];
const expression = typeof schema?.expression === "string" ? schema.expression.trim() : "";
const formulaJS = typeof schema?.formula_js === "string" ? schema.formula_js.trim() : "";
const units = schema?.units || { input: "", output: "" };
const disclaimer = schema?.disclaimer || "Educational information, not professional advice.";
---

<section class="calculator not-prose">
  <form id="calc-form" class="space-y-4" novalidate>
    <div class="grid gap-3">
      {inputs.map((f, idx) => (
        <div class="flex flex-col" id={`field-${f.name}`}>
          <label for={`inp-${f.name}`} class="font-medium">{f.hint || f.name}</label>
          <input
            id={`inp-${f.name}`}
            name={f.name}
            type={f.type || "number"}
            step={f.step ?? "any"}
            min={typeof f.min !== "undefined" ? f.min : undefined}
            max={typeof f.max !== "undefined" ? f.max : undefined}
            inputmode="decimal"
            class="border rounded px-3 py-2"
            required
          />
          <small id={`err-${f.name}`} class="text-red-600 hidden"></small>
        </div>
      ))}
    </div>

    <button id="btn-calc" type="submit" class="border rounded px-4 py-2">
      Calculate
    </button>

    <div id="result" class="mt-3" aria-live="polite" role="status"></div>
  </form>

  <p class="text-xs opacity-70 mt-4">{disclaimer}</p>
</section>

<style>
.hidden{ display:none }
</style>

<script>
(function(){
  const form = document.getElementById("calc-form");
  const resultEl = document.getElementById("result");

  const fmt = new Intl.NumberFormat(${JSON.stringify(locale)}, { maximumFractionDigits: 8 });

  function getValues(){
    const vals = {};
    for (const el of form.elements) {
      if (!el.name) continue;
      const v = (el.value || "").trim();
      if (v === "") { vals[el.name] = NaN; continue; }
      const num = Number(v);
      vals[el.name] = Number.isFinite(num) ? num : NaN;
    }
    return vals;
  }

  function clearErrors(){
    for (const el of form.elements) {
      if (!el.name) continue;
      const err = document.getElementById(`err-${el.name}`);
      if (err) { err.textContent=""; err.classList.add("hidden"); }
      const wrap = document.getElementById(`field-${el.name}`);
      if (wrap) wrap.removeAttribute("aria-invalid");
    }
  }

  function showError(name, msg){
    const err = document.getElementById(`err-${name}`);
    if (err) { err.textContent = msg; err.classList.remove("hidden"); }
    const wrap = document.getElementById(`field-${name}`);
    if (wrap) wrap.setAttribute("aria-invalid", "true");
  }

  // Very small, sanitized evaluator for arithmetic expressions.
  function evalExpression(raw, scope){
    // Allowed tokens: numbers, operators + - * / % ^, parentheses, dot, spaces, variable names [a-zA-Z_][a-zA-Z0-9_]*
    const varNames = Object.keys(scope);
    // Replace variables with their numeric values (or NaN if missing)
    let expr = raw;
    // Sort by length desc to avoid partial replacements
    varNames.sort((a,b)=>b.length-a.length);
    for (const k of varNames) {
      const re = new RegExp(`\\b${k}\\b`, "g");
      expr = expr.replace(re, String(scope[k]));
    }
    // Validate characters
    if (!/^[0-9+\-*/%^().,\sNaInfty\-eE]+$/.test(expr)) {
      throw new Error("Invalid characters in expression.");
    }
    // Replace ^ with ** for JS exponent
    expr = expr.replace(/\^/g, "**");
    // Prevent unsafe patterns
    if (/([A-Za-z_][A-Za-z0-9_]*|\{|\}|\[|\]|new|function|=>|;)/.test(expr)) {
      throw new Error("Unsafe token detected.");
    }
    const fn = new Function(`return (${expr});`);
    const out = fn();
    if (typeof out !== "number" || !Number.isFinite(out)) throw new Error("Computation failed.");
    return out;
  }

  function compute(vals){
    // Prefer expression; fallback to formula_js if provided and safe
    const hasExpr = ${JSON.stringify(!!expression)};
    const hasFormula = ${JSON.stringify(!!formulaJS)};

    if (hasExpr) {
      return evalExpression(${JSON.stringify(expression)}, vals);
    } else if (hasFormula) {
      // Expect a pure function string like: (inputs) => ({ result, steps })
      // We compile in a tight closure with no globals.
      const src = ${JSON.stringify(formulaJS)};
      if (/new |Function|fetch|XMLHttpRequest|window|document|eval/.test(src)) {
        throw new Error("Unsafe formula_js.");
      }
      const fn = (0,eval)(src); // still blocked by pattern above
      const out = fn(vals);
      if (out && typeof out.result === "number" && Number.isFinite(out.result)) return out.result;
      throw new Error("formula_js did not return a numeric result.");
    } else {
      throw new Error("No expression or formula_js provided.");
    }
  }

  form.addEventListener("submit", (ev)=>{
    ev.preventDefault();
    clearErrors();
    try{
      const vals = getValues();
      // validate empties
      for (const [k,v] of Object.entries(vals)) {
        if (!Number.isFinite(v)) { showError(k, "Enter a valid number"); }
      }
      const bad = Object.entries(vals).some(([,v])=>!Number.isFinite(v));
      if (bad) { resultEl.textContent = ""; return; }
      const res = compute(vals);
      resultEl.textContent = "Result: " + fmt.format(res) + ( ${JSON.stringify(units.output or "")} ? " ${units.output}" : "" );
    }catch(e){
      console.error(e);
      resultEl.textContent = "Unable to compute. Please check your inputs.";
    }
  });
})();
</script>
