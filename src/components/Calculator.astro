---
const { schema } = Astro.props;
/** Server-only: derivar lista de inputs y llaves permitidas */
const inputs = Array.isArray(schema?.inputs) ? schema.inputs : [];
const allowed = new Set(inputs.map(i => i.name));
const expression = (schema?.expression || "").toString();
const exprJS = expression.replace(/\^/g, "**"); // soporta ^ como potencia
---

<div class="box" aria-labelledby="calc-h">
  <h2 id="calc-h" style="margin-top:0">{schema?.title || "Calculator"}</h2>

  <form id="calc-form" onsubmit="return false;" novalidate>
    {inputs.map((inp, idx) => (
      <div>
        <label for={`f-${idx}`}>{inp.hint || inp.name}</label>
        <input
          id={`f-${idx}`}
          name={inp.name}
          type="number"
          min={inp.min ?? undefined}
          max={inp.max ?? undefined}
          step={inp.step ?? "any"}
          inputmode="decimal"
          aria-describedby={`d-${idx}`}
        />
        <div id={`d-${idx}`} class="muted">{inp.hint || ""}</div>
      </div>
    ))}
    <div style="margin-top:12px">
      <button class="btn" id="calc-btn" type="button">Calculate</button>
    </div>
  </form>

  <div id="calc-out" class="box" role="status" aria-live="polite">Result: —</div>

  <script is:inline>
    (() => {{
      const form = document.getElementById('calc-form');
      const out = document.getElementById('calc-out');
      const btn = document.getElementById('calc-btn');

      const names = {JSON.stringify([i["name"] for i in []])}; // placeholder, replaced below
    }})();
  </script>
</div>

<!-- Script cliente separado para evitar acceso a window/document en fase server -->
<script is:inline>
(() => {
  const inputs = {JSON.stringify(inputs)};
  const allowed = new Set(inputs.map(i => i.name));
  const expr = {JSON.stringify(exprJS)};

  function num(v) {
    const n = Number(v);
    return Number.isFinite(n) ? n : NaN;
  }

  function buildContext() {
    const ctx = {};
    inputs.forEach((inp, idx) => {
      const el = document.getElementById('f-' + idx);
      ctx[inp.name] = num(el?.value);
    });
    return ctx;
  }

  function validateContext(ctx) {
    return Object.values(ctx).every(v => Number.isFinite(v));
  }

  function evalSafe(expr, ctx) {
    // reemplaza identificadores por parámetros y evalúa de forma acotada usando Function con parámetros
    const vars = Object.keys(ctx);
    // Verifica que sólo haya identificadores permitidos
    const identRE = /[A-Za-z_][A-Za-z0-9_]*/g;
    let ok = true;
    expr.replace(identRE, (m) => {
      if (!vars.includes(m)) ok = false;
      return m;
    });
    if (!ok) throw new Error('Invalid token in expression');

    const fn = new Function(...vars, `'use strict'; return ( ${expr} );`);
    const args = vars.map(k => ctx[k]);
    const val = fn(...args);
    return val;
  }

  function format(val) {
    if (!Number.isFinite(val)) return '—';
    try {
      return new Intl.NumberFormat('en-US', { maximumFractionDigits: 6 }).format(val);
    } catch {
      return String(val);
    }
  }

  function compute() {
    const ctx = buildContext();
    if (!validateContext(ctx)) {
      out.textContent = 'Result: —';
      return;
    }
    try {
      const value = evalSafe(expr, ctx);
      out.textContent = 'Result: ' + format(value);
    } catch (e) {
      out.textContent = 'Result: —';
      console.error(e);
    }
  }

  const out = document.getElementById('calc-out');
  const btn = document.getElementById('calc-btn');
  btn?.addEventListener('click', compute);
  inputs.forEach((_, idx) => {
    const el = document.getElementById('f-' + idx);
    el?.addEventListener('input', compute);
  });
})();
</script>
